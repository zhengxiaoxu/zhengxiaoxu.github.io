<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Mac下编译FFMPEG]]></title>
      <url>%2F2017%2F12%2F20%2FMac%E4%B8%8B%E7%BC%96%E8%AF%91FFMPEG%2F</url>
      <content type="text"><![CDATA[今天开始学习Android NDK，于是尝试着先学习如何编译FFMPEG的so文件。这里记录下细节。 步骤 环境准备 下载NDK 到Android Studio中进行下载： 到官网进行下载：https://dl.google.com/android/repository/android-ndk-r14b-darwin-x86_64.zip?hl=zh-cn 下载FFMPEG源代码: http://ffmpeg.org/releases/ffmpeg-3.4.1.tar.xz 解压好NDK包和FFMPEG包 进入到解压好的FFMPEG目录下，书写build_android.sh脚本文件，注意运行的时候把里面的##注释行去掉 12345678910111213141516171819202122232425262728293031323334353637#!/bin/bash## 这里xxxxxxx替换成自己电脑的用户名，指定NDK的路径NDK=/Users/xxxxxxx/Documents/workspace/android-ndk-r14bexport PATH=$PATH:$NDKSYSROOT=$NDK/platforms/android-19/arch-arm/TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64## 由于在运行本脚本文件过程中报错了，于是这里指定了pkg-config的路径，这个坑具体会在后面详细说明PKG_CONFIG_HOST_BINARY=/usr/local/bin/pkg-configfunction build_one&#123;bash ./configure \ --prefix=$PREFIX \ --enable-shared \ --disable-doc \ --disable-ffserver \ --enable-cross-compile \ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \ --pkg-config=$PKG_CONFIG_HOST_BINARY \ --target-os=android \ --arch=arm \ --extra-libs=-lgcc \ --sysroot=$SYSROOT \ --enable-asm \ --enable-neon \ --extra-cflags="-O3 -fpic $ADDI_CFLAGS" \ --extra-ldflags="$ADDI_LDFLAGS" \ $ADDITIONAL_CONFIGURE_FLAGmake cleanmakemake install&#125;CPU=armPREFIX=$(pwd)/android/$CPUADDI_CFLAGS="-marm -mfpu=neon"build_one 依次运行命令 123chmod 777 build_android.sh./build_android.shmake -j4 &amp;&amp; make install 完成后会在android目录中看到生成的so文件 遇到的问题及解决方案在首次编译的时候报了个warning没太在意： 1WARNING: /Users/xxxxxxx/Documents/workspace/android-ndk-r14b/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86/bin/arm-linux-androideabi-pkg-config not found, library detection may fail. 于是导致了后面头文件找不到的情况，导致编译终止。 于是按照这个warning路径去寻找，发现NDK路径下没有arm-linux-androideabi-pkg-config这个文件。找了解决办法是调用系统的pkg-config文件，在/usr/local/bin中查找，发现Mac下依旧没有这个pkg-config文件。 现在需要为Mac安装pkg-config文件： 下载并解压：http://pkgconfig.freedesktop.org/releases/pkg-config-0.28.tar.gz 进入到解压后的目录下，一次执行如下代码： 123./configure --with-internal-glibmakesudo make install 运行结束后再到/usr/local/bin/中就能看到这个文件了，然后在上面的build_android.sh中配置这个--pkg-config 参数，指向这里。 再次运行build_android.sh脚本，warning消失。 以上就是这次编译NDK的具体过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仿微信6-0界面笔记]]></title>
      <url>%2F2017%2F07%2F18%2F%E4%BB%BF%E5%BE%AE%E4%BF%A16-0%E7%95%8C%E9%9D%A2%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[在慕课网上学习了张鸿阳老师的高仿微信6.0 Android界面的课程，在此记录下学习笔记。这里借用下老师的动态图，自己的App界面图标比较丑，网上找了几个icon作为绘制标本。 变色原理介绍Graphics/Xfermode原理图 步骤这里主要是利用了Paint的Xfermode，使用的是Mode.DST_IN模式 绘制Dst图 绘制Src图 在此模式下，显示的是Dst和Src的交集区域，填充内容为Dst的图片内容 自定义底部的TabView步骤定义属性文件attr.xml 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;attr name="icon" format="reference"&gt;&lt;/attr&gt; &lt;attr name="color" format="color"&gt;&lt;/attr&gt; &lt;attr name="text" format="string"&gt;&lt;/attr&gt; &lt;attr name="text_size" format="dimension"&gt;&lt;/attr&gt; &lt;declare-styleable name="ChangeIconWithText"&gt; &lt;attr name="icon"&gt;&lt;/attr&gt; &lt;attr name="color"&gt;&lt;/attr&gt; &lt;attr name="text"&gt;&lt;/attr&gt; &lt;attr name="text_size"&gt;&lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在布局文件activity_wechat.xml中使用我们定义好的attr.xml属性文件，这一步需要记得设置命名空间 1234567 &lt;!--这里设置命名空间--&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:zxx="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; 1234567891011&lt;!-- 使用attr.xml定义的属性 --&gt;&lt;com.example.simonzheng.demo1.ChangeIconWithText android:id="@+id/id_indicator_one" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:padding="5dp" zxx:color="#ff45c01a" zxx:icon="@drawable/wechat" zxx:text="@string/app_name_wechat" zxx:text_size="12sp" /&gt; 在构造方法中去获取自定义的属性，这里的目的是获得这些值，为后面的绘制做准备 12345678910111213141516171819202122232425262728293031323334public ChangeIconWithText(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ChangeIconWithText); int n = a.getIndexCount(); for (int i = 0; i &lt; n; i++) &#123; int attr = a.getIndex(i); switch (attr) &#123; case R.styleable.ChangeIconWithText_icon: BitmapDrawable drawable = (BitmapDrawable) a.getDrawable(attr); mIconBitmap = drawable.getBitmap(); break; case R.styleable.ChangeIconWithText_color: mColor = a.getColor(attr, 0xff45c01a); break; case R.styleable.ChangeIconWithText_text: mText = a.getString(attr); break; case R.styleable.ChangeIconWithText_text_size: mTextSize = (int) a.getDimension(attr, TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 12, getResources().getDisplayMetrics()) ); break; &#125; &#125; a.recycle(); mTextBound = new Rect(); mTextPaint = new Paint(); mTextPaint.setTextSize(mTextSize); mTextPaint.setColor(0xff555555); mTextPaint.getTextBounds(mText, 0, mText.length(), mTextBound);&#125; 实现onMeasure方法 12345678910111213141516171819/** * icon的边长： view的宽度 - leftpadding - rightpadding * view的高度 - toppadding - bottompadding - mTextBound.height * * @param widthMeasureSpec * @param heightMeasureSpec */@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int iconWidth = Math.min(getMeasuredWidth() - getPaddingLeft() - getPaddingRight(), getMeasuredHeight() - getPaddingTop() - getPaddingBottom() - mTextBound.height()); int left = getMeasuredWidth() / 2 - iconWidth / 2; int top = getMeasuredHeight() / 2 - (mTextBound.height() + iconWidth) / 2; mIconRect = new Rect(left, top, left + iconWidth, top + iconWidth);&#125; 实现onDraw方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Overrideprotected void onDraw(Canvas canvas) &#123; //绘制原图 canvas.drawBitmap(mIconBitmap, null, mIconRect, null); //内存中准备mBitmap, setAlpha, 纯色, xfermode, 图标 int alpha = (int) Math.ceil(255 * mAlpha); setupTargetBitmap(alpha); //绘制原文本 drawSourceText(canvas, alpha); //绘制变色文本 drawTargetText(canvas, alpha); canvas.drawBitmap(mBitmap, 0, 0, null); super.onDraw(canvas);&#125;/** * 绘制变色文本 * * @param canvas * @param alpha */private void drawTargetText(Canvas canvas, int alpha) &#123; mTextPaint.setColor(mColor); mTextPaint.setAlpha(alpha); int x = getMeasuredWidth() / 2 - mTextBound.width() / 2; int y = mIconRect.bottom + mTextBound.height(); canvas.drawText(mText, x, y, mTextPaint);&#125;/** * 绘制原文本 * * @param canvas * @param alpha */private void drawSourceText(Canvas canvas, int alpha) &#123; mTextPaint.setColor(0xff333333); mTextPaint.setAlpha(255 - alpha); int x = getMeasuredWidth() / 2 - mTextBound.width() / 2; int y = mIconRect.bottom + mTextBound.height(); canvas.drawText(mText, x, y, mTextPaint);&#125;/** * 在内存中绘制可变色icon */private void setupTargetBitmap(int alpha) &#123; mBitmap = Bitmap.createBitmap(getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888); mCanvas = new Canvas(mBitmap); mPaint = new Paint(); mPaint.setColor(mColor); mPaint.setDither(true); mPaint.setAntiAlias(true); mPaint.setAlpha(alpha); mCanvas.drawRect(mIconRect, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); mPaint.setAlpha(255); mCanvas.drawBitmap(mIconBitmap, null, mIconRect, mPaint);&#125; ViewPager在滑动的时候，positionOffset的值会从0到1改变，可以通过这个值来改变图标的alpha值，从而达到图标颜色渐变的效果 12345678910@Overridepublic void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; Log.d("TAG", "position= " + position + ", " + positionOffset); if (positionOffset &gt; 0) &#123; ChangeIconWithText left = mTabIndicators.get(position); ChangeIconWithText right = mTabIndicators.get(position + 1); left.setIconAlpha( 1- positionOffset); right.setIconAlpha(positionOffset); &#125;&#125; 在实现顶部menu的过程中的一些小注意事项AppCompatActivity这里我的Wechat activity继承自AppCompatActivity，在这里为了让右上角的弹出菜单能够显示icon，视频中是在重写onMenuOpened的方法。但是在AppCompatActivity，我们需要把强制设置图标显示的代码放到onPrepareOptionsMenu方法中，像这样： 12345678910111213141516171819@Overridepublic boolean onPrepareOptionsMenu(Menu menu) &#123; if (menu != null) &#123; if (menu.getClass().getSimpleName().equals("MenuBuilder")) &#123; try &#123; Method m = menu.getClass().getDeclaredMethod("setOptionalIconsVisible", Boolean.TYPE); m.setAccessible(true); m.invoke(menu, true); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return super.onPrepareOptionsMenu(menu);&#125; 替换右上角的菜单按钮 在styles.xml文件中写样式去替换相应的图标, 这里由于我的icon为透明色，跟弹出菜单的底色搭配后显得看不清，于是我做了修改去把颜色改为黑灰色，并且把菜单项的颜色改为了白色。 123456789101112131415161718&lt;style name="MyTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="android:actionOverflowButtonStyle"&gt;@style/WechatActionOverflowButtonStyle&lt;/item&gt; &lt;item name="actionOverflowButtonStyle"&gt;@style/WechatActionOverflowButtonStyle&lt;/item&gt; &lt;item name="actionOverflowMenuStyle"&gt;@style/WechatPopupMenuStyle&lt;/item&gt; &lt;item name="android:itemTextAppearance"&gt;@style/WechatPopupMenuTextStyle&lt;/item&gt;&lt;/style&gt;&lt;style name="WechatActionOverflowButtonStyle"&gt; &lt;item name="android:src"&gt;@drawable/actionbar_add_icon&lt;/item&gt;&lt;/style&gt;&lt;style name="WechatPopupMenuStyle" parent="Theme.AppCompat.CompactMenu"&gt; &lt;item name="android:popupBackground"&gt;@color/colorGrayDark&lt;/item&gt;&lt;/style&gt;&lt;style name="WechatPopupMenuTextStyle"&gt; &lt;item name="android:textColor"&gt;@color/colorWhite&lt;/item&gt;&lt;/style&gt; 如下代码是用来强制把菜单第一项和菜单icon合并的代码，在这里我用的是AppCompatActivity，以下代码对于我的app貌似无效，我的做法是去掉了菜单列表的Add item。 123456789101112private void setOverflowButtonAlways() &#123; try &#123; ViewConfiguration config = ViewConfiguration.get(this); Field menuKey = ViewConfiguration.class.getDeclaredField("sHasPermanentMenuKey"); menuKey.setAccessible(true); menuKey.setBoolean(config, false); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125; 防止程序被Kill后，Tab的状态和ViewPager状态不同步的问题在程序被Kill了以后，我们的Tab状态和ViewPager无法同步，视频中是使用横竖屏来强制页面重绘来模拟这个情况，我们需要复写如下方法并保存tab的状态： 123456789101112131415161718192021private static final String INSTANCE_STATUS = "instance_status";private static final String STATUS_ALPHA = "status_alpha";@Overrideprotected Parcelable onSaveInstanceState() &#123; Bundle bundle = new Bundle(); bundle.putParcelable(INSTANCE_STATUS, super.onSaveInstanceState()); bundle.putFloat(STATUS_ALPHA, mAlpha); return bundle;&#125;@Overrideprotected void onRestoreInstanceState(Parcelable state) &#123; if (state instanceof Bundle) &#123; Bundle bundle = (Bundle) state; mAlpha = bundle.getFloat(STATUS_ALPHA); super.onRestoreInstanceState(bundle.getParcelable(INSTANCE_STATUS)); return; &#125; super.onRestoreInstanceState(state);&#125; 以上就是这次的学习笔记，更多详情可以参考下老师的博客：Android 高仿微信6.0主界面 带你玩转切换图标变色]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F07%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
